import path from 'node:path';
import { existsSync } from 'node:fs';
import hasha from 'hasha';
import chokidar from 'chokidar';
import { importUserModule, logger, readPackageConfig } from '@reskript/core';
import validate from './validate.js';
import { fillProjectSettings, } from './defaults.js';
import { applyPlugins } from './plugins.js';
export * from './interface/index.js';
export { fillProjectSettings };
const SETTINGS_EXTENSIONS = ['.ts', '.mjs'];
const checkSettingsExists = (file) => {
    if (file && !existsSync(file)) {
        logger.error(`Unable to find configuration file ${file}`);
        process.exit(21);
    }
};
const locateSettings = (cwd) => {
    const file = SETTINGS_EXTENSIONS.map(v => path.join(cwd, 'reskript.config' + v)).find(existsSync);
    return file !== null && file !== void 0 ? file : null;
};
const importSettings = async (options) => {
    const { specifiedFile, ...cmd } = options;
    const { resolved, value: { default: userSettings } } = await importUserModule(specifiedFile ? [specifiedFile] : SETTINGS_EXTENSIONS.map(v => path.join(cmd.cwd, 'reskript.config' + v)), { default: { driver: 'webpack' } });
    try {
        validate(userSettings);
    }
    catch (ex) {
        logger.error(ex instanceof Error ? ex.message : `${ex}`);
        process.exit(21);
    }
    const { plugins = [], ...clientSettings } = userSettings;
    const rawSettings = { ...fillProjectSettings(clientSettings), from: resolved };
    return applyPlugins(rawSettings, plugins, cmd);
};
const cache = {
    initialized: false,
    hash: '',
    settings: fillProjectSettings({ driver: 'webpack' }),
    listen: null,
};
export const readProjectSettings = async (options) => {
    checkSettingsExists(options.specifiedFile);
    if (cache.initialized) {
        return cache.settings;
    }
    const settings = await importSettings(options);
    cache.initialized = true;
    cache.settings = settings;
    return settings;
};
export const watchProjectSettings = async (options) => {
    var _a;
    checkSettingsExists(options.specifiedFile);
    if (cache.listen) {
        return cache.listen;
    }
    const settingsLocation = (_a = options.specifiedFile) !== null && _a !== void 0 ? _a : locateSettings(options.cwd);
    // 根本没有配置文件，弄个空的回去随便外面怎么折腾
    if (!settingsLocation) {
        return () => () => { };
    }
    const listeners = new Set();
    const watcher = chokidar.watch(settingsLocation);
    const notify = async () => {
        // `fs.watch`是不稳定的，一次修改会触发多次，因此用hash做一下比对
        const newSettingsHash = await hasha.fromFile(settingsLocation);
        if (newSettingsHash === cache.hash) {
            return;
        }
        cache.hash = newSettingsHash;
        listeners.forEach(f => f());
    };
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    watcher.on('all', notify);
    cache.hash = await hasha.fromFile(settingsLocation);
    cache.listen = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
    };
    return cache.listen;
};
export const warnAndExitOnInvalidFinalizeReturn = (value, scope) => {
    if (!value) {
        const message = `
            Your ${scope}.finalize returns nothing.
            You may forget to write a return statement in ${scope}.finalize, or some plugin has a broken implement.
        `;
        logger.error(message);
        process.exit(21);
    }
};
const hasDependency = (packageInfo, name) => {
    const { dependencies, devDependencies } = packageInfo;
    return !!((dependencies === null || dependencies === void 0 ? void 0 : dependencies[name]) || (devDependencies === null || devDependencies === void 0 ? void 0 : devDependencies[name]));
};
export const strictCheckRequiredDependency = async (projectSettings, cwd) => {
    const hostPackageInfo = await readPackageConfig(cwd);
    if (projectSettings.build.script.polyfill && !hasDependency(hostPackageInfo, 'core-js')) {
        logger.error('You require polyfill on build but don\'t have core-js installed.');
        process.exit(13);
    }
};
export function configure(driver, settings) {
    return { ...settings, driver };
}
